<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>QCQPcpp: qcqpcpp::MosekOpt&lt; _Scalar &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">QCQPcpp
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerator</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>qcqpcpp</b></li><li class="navelem"><a class="el" href="classqcqpcpp_1_1_mosek_opt.html">MosekOpt</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classqcqpcpp_1_1_mosek_opt-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">qcqpcpp::MosekOpt&lt; _Scalar &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Specialization of optimisation problem to solve using the Mosek solver.  
 <a href="classqcqpcpp_1_1_mosek_opt.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="mosek_opt_problem_8h_source.html">mosekOptProblem.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for qcqpcpp::MosekOpt&lt; _Scalar &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classqcqpcpp_1_1_mosek_opt__inherit__graph.png" border="0" usemap="#qcqpcpp_1_1_mosek_opt_3_01___scalar_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="qcqpcpp_1_1_mosek_opt_3_01___scalar_01_4_inherit__map" id="qcqpcpp_1_1_mosek_opt_3_01___scalar_01_4_inherit__map">
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for qcqpcpp::MosekOpt&lt; _Scalar &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classqcqpcpp_1_1_mosek_opt__coll__graph.png" border="0" usemap="#qcqpcpp_1_1_mosek_opt_3_01___scalar_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="qcqpcpp_1_1_mosek_opt_3_01___scalar_01_4_coll__map" id="qcqpcpp_1_1_mosek_opt_3_01___scalar_01_4_coll__map">
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:af2179c57b18f865f2f20edee67a53d66"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af2179c57b18f865f2f20edee67a53d66"></a>
typedef <a class="el" href="classqcqpcpp_1_1_opt_problem.html">OptProblem</a>&lt; _Scalar &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcqpcpp_1_1_mosek_opt.html#af2179c57b18f865f2f20edee67a53d66">ParentType</a></td></tr>
<tr class="memdesc:af2179c57b18f865f2f20edee67a53d66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parent type typedef. <br/></td></tr>
<tr class="separator:af2179c57b18f865f2f20edee67a53d66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb2bcd596dc1d59d5e1de075957c02b3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adb2bcd596dc1d59d5e1de075957c02b3"></a>
typedef <a class="el" href="classqcqpcpp_1_1_opt_problem.html#abefbee54ef45776816979486f4a34968">ParentType::Scalar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcqpcpp_1_1_mosek_opt.html#adb2bcd596dc1d59d5e1de075957c02b3">Scalar</a></td></tr>
<tr class="memdesc:adb2bcd596dc1d59d5e1de075957c02b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Coefficient storage type inherited from parent. <br/></td></tr>
<tr class="separator:adb2bcd596dc1d59d5e1de075957c02b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98eacebd160a94e3baa64bad18c56c7e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a98eacebd160a94e3baa64bad18c56c7e"></a>
typedef <a class="el" href="classqcqpcpp_1_1_opt_problem.html#a716e2039dd95ed8cf743427f10b1c295">ParentType::ReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcqpcpp_1_1_mosek_opt.html#a98eacebd160a94e3baa64bad18c56c7e">ReturnType</a></td></tr>
<tr class="memdesc:a98eacebd160a94e3baa64bad18c56c7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation return type inherited from parent (aka MSKrescodee in this case). <br/></td></tr>
<tr class="separator:a98eacebd160a94e3baa64bad18c56c7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bf8533feaa274c2fc6686594d2d6a1c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5bf8533feaa274c2fc6686594d2d6a1c"></a>
typedef <a class="el" href="classqcqpcpp_1_1_opt_problem.html#a07145ca39acf400966c4a389cd3d0f11">ParentType::OBJ_SENSE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcqpcpp_1_1_mosek_opt.html#a5bf8533feaa274c2fc6686594d2d6a1c">OBJ_SENSE</a></td></tr>
<tr class="memdesc:a5bf8533feaa274c2fc6686594d2d6a1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Problem optimization sense type inherited from parent. <br/></td></tr>
<tr class="separator:a5bf8533feaa274c2fc6686594d2d6a1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae04ead3543d16ad4402331fd5d4ba6d5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae04ead3543d16ad4402331fd5d4ba6d5"></a>
typedef <a class="el" href="classqcqpcpp_1_1_opt_problem.html#a3e82865d53426ef80b332476dd53a0c8">ParentType::BOUND</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcqpcpp_1_1_mosek_opt.html#ae04ead3543d16ad4402331fd5d4ba6d5">BOUND</a></td></tr>
<tr class="memdesc:ae04ead3543d16ad4402331fd5d4ba6d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Problem bound type inherited from parent. <br/></td></tr>
<tr class="separator:ae04ead3543d16ad4402331fd5d4ba6d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e8b1f60d38032e35d64ff9f1864388c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6e8b1f60d38032e35d64ff9f1864388c"></a>
typedef <a class="el" href="classqcqpcpp_1_1_opt_problem.html#ae969d5bba7f88aedcc72d410fcb3db1b">ParentType::VAR_TYPE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcqpcpp_1_1_mosek_opt.html#a6e8b1f60d38032e35d64ff9f1864388c">VAR_TYPE</a></td></tr>
<tr class="memdesc:a6e8b1f60d38032e35d64ff9f1864388c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Problem variable continuity type inherited from parent. <br/></td></tr>
<tr class="separator:a6e8b1f60d38032e35d64ff9f1864388c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2cdfabdefcfeed7505dba277dfb7c38"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa2cdfabdefcfeed7505dba277dfb7c38"></a>
typedef <a class="el" href="classqcqpcpp_1_1_opt_problem.html#a459f2a7adb112a97b5e358b969791a3a">ParentType::SparseMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcqpcpp_1_1_mosek_opt.html#aa2cdfabdefcfeed7505dba277dfb7c38">SparseMatrix</a></td></tr>
<tr class="memdesc:aa2cdfabdefcfeed7505dba277dfb7c38"><td class="mdescLeft">&#160;</td><td class="mdescRight">SparseMatrix type inherited from parent. <br/></td></tr>
<tr class="separator:aa2cdfabdefcfeed7505dba277dfb7c38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classqcqpcpp_1_1_opt_problem"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classqcqpcpp_1_1_opt_problem')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classqcqpcpp_1_1_opt_problem.html">qcqpcpp::OptProblem&lt; _Scalar &gt;</a></td></tr>
<tr class="memitem:a07145ca39acf400966c4a389cd3d0f11 inherit pub_types_classqcqpcpp_1_1_opt_problem"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcqpcpp_1_1_opt_problem.html#a07145ca39acf400966c4a389cd3d0f11">OBJ_SENSE</a> { <a class="el" href="classqcqpcpp_1_1_opt_problem.html#a07145ca39acf400966c4a389cd3d0f11a23cb71a72fba709b41d0534eb78b51b4">MINIMIZE</a>, 
<a class="el" href="classqcqpcpp_1_1_opt_problem.html#a07145ca39acf400966c4a389cd3d0f11a4bd297c45b043be46923450596b969b9">MAXIMIZE</a>
 }</td></tr>
<tr class="separator:a07145ca39acf400966c4a389cd3d0f11 inherit pub_types_classqcqpcpp_1_1_opt_problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae969d5bba7f88aedcc72d410fcb3db1b inherit pub_types_classqcqpcpp_1_1_opt_problem"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcqpcpp_1_1_opt_problem.html#ae969d5bba7f88aedcc72d410fcb3db1b">VAR_TYPE</a> { <a class="el" href="classqcqpcpp_1_1_opt_problem.html#ae969d5bba7f88aedcc72d410fcb3db1bac9261c35c06d73e7bd00a8f5e3a0e296">CONTINUOUS</a> = 0, 
<a class="el" href="classqcqpcpp_1_1_opt_problem.html#ae969d5bba7f88aedcc72d410fcb3db1babe24261504d674b6106a3165b5d0f6a2">INTEGER</a> = 1, 
<b>BINARY</b> = 2
 }</td></tr>
<tr class="separator:ae969d5bba7f88aedcc72d410fcb3db1b inherit pub_types_classqcqpcpp_1_1_opt_problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f22877410f8de2172c59ef24d288e1a inherit pub_types_classqcqpcpp_1_1_opt_problem"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcqpcpp_1_1_opt_problem.html#a7f22877410f8de2172c59ef24d288e1a">LINEARITY</a> { <b>LINEAR</b> = 0, 
<a class="el" href="classqcqpcpp_1_1_opt_problem.html#a7f22877410f8de2172c59ef24d288e1aac114b9388cace972248dd934b644c005">NON_LINEAR</a> = 1
 }</td></tr>
<tr class="separator:a7f22877410f8de2172c59ef24d288e1a inherit pub_types_classqcqpcpp_1_1_opt_problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e82865d53426ef80b332476dd53a0c8 inherit pub_types_classqcqpcpp_1_1_opt_problem"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcqpcpp_1_1_opt_problem.html#a3e82865d53426ef80b332476dd53a0c8">BOUND</a> { <br/>
&#160;&#160;<a class="el" href="classqcqpcpp_1_1_opt_problem.html#a3e82865d53426ef80b332476dd53a0c8ae304f5cf19a149d204adf622885fc9f3">GREATER_EQ</a> = 0, 
<a class="el" href="classqcqpcpp_1_1_opt_problem.html#a3e82865d53426ef80b332476dd53a0c8af7b7f4f4536f65028ded38d54e9d96e4">LESS_EQ</a> = 1, 
<a class="el" href="classqcqpcpp_1_1_opt_problem.html#a3e82865d53426ef80b332476dd53a0c8aa74a008fd4c6290126ebffd2dcc2fee9">EQUAL</a> = 2, 
<a class="el" href="classqcqpcpp_1_1_opt_problem.html#a3e82865d53426ef80b332476dd53a0c8a69e2784970e35c1f9ec3410678710f82">FREE</a> = 3, 
<br/>
&#160;&#160;<a class="el" href="classqcqpcpp_1_1_opt_problem.html#a3e82865d53426ef80b332476dd53a0c8a2191ac429e9bb5aca1b5363a319ace27">RANGE</a> = 4
<br/>
 }</td></tr>
<tr class="separator:a3e82865d53426ef80b332476dd53a0c8 inherit pub_types_classqcqpcpp_1_1_opt_problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abefbee54ef45776816979486f4a34968 inherit pub_types_classqcqpcpp_1_1_opt_problem"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abefbee54ef45776816979486f4a34968"></a>
typedef _Scalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcqpcpp_1_1_opt_problem.html#abefbee54ef45776816979486f4a34968">Scalar</a></td></tr>
<tr class="memdesc:abefbee54ef45776816979486f4a34968 inherit pub_types_classqcqpcpp_1_1_opt_problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Some implementations require this to be double (i.e. Mosek does). <br/></td></tr>
<tr class="separator:abefbee54ef45776816979486f4a34968 inherit pub_types_classqcqpcpp_1_1_opt_problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a716e2039dd95ed8cf743427f10b1c295 inherit pub_types_classqcqpcpp_1_1_opt_problem"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a716e2039dd95ed8cf743427f10b1c295"></a>
typedef int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcqpcpp_1_1_opt_problem.html#a716e2039dd95ed8cf743427f10b1c295">ReturnType</a></td></tr>
<tr class="memdesc:a716e2039dd95ed8cf743427f10b1c295 inherit pub_types_classqcqpcpp_1_1_opt_problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Error code storage type. <br/></td></tr>
<tr class="separator:a716e2039dd95ed8cf743427f10b1c295 inherit pub_types_classqcqpcpp_1_1_opt_problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00fc3821814ec59c74df4a47467b0eb7 inherit pub_types_classqcqpcpp_1_1_opt_problem"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a00fc3821814ec59c74df4a47467b0eb7"></a>
typedef Eigen::Matrix&lt; _Scalar,-1, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcqpcpp_1_1_opt_problem.html#a00fc3821814ec59c74df4a47467b0eb7">VectorX</a></td></tr>
<tr class="memdesc:a00fc3821814ec59c74df4a47467b0eb7 inherit pub_types_classqcqpcpp_1_1_opt_problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">RowVector of unkown dimensions. <br/></td></tr>
<tr class="separator:a00fc3821814ec59c74df4a47467b0eb7 inherit pub_types_classqcqpcpp_1_1_opt_problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10f061897d333c3c3fbad09fc6031695 inherit pub_types_classqcqpcpp_1_1_opt_problem"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a10f061897d333c3c3fbad09fc6031695"></a>
typedef Eigen::Triplet&lt; <a class="el" href="classqcqpcpp_1_1_opt_problem.html#abefbee54ef45776816979486f4a34968">Scalar</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcqpcpp_1_1_opt_problem.html#a10f061897d333c3c3fbad09fc6031695">SparseEntry</a></td></tr>
<tr class="memdesc:a10f061897d333c3c3fbad09fc6031695 inherit pub_types_classqcqpcpp_1_1_opt_problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">This type is an element of a list of entries before construction of a SparseMatrix. <br/></td></tr>
<tr class="separator:a10f061897d333c3c3fbad09fc6031695 inherit pub_types_classqcqpcpp_1_1_opt_problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5aba17776d02422e2d40bc44f420c3c inherit pub_types_classqcqpcpp_1_1_opt_problem"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae5aba17776d02422e2d40bc44f420c3c"></a>
typedef std::vector&lt; <a class="el" href="classqcqpcpp_1_1_opt_problem.html#a10f061897d333c3c3fbad09fc6031695">SparseEntry</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcqpcpp_1_1_opt_problem.html#ae5aba17776d02422e2d40bc44f420c3c">SparseEntries</a></td></tr>
<tr class="memdesc:ae5aba17776d02422e2d40bc44f420c3c inherit pub_types_classqcqpcpp_1_1_opt_problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">A list of entries before construction. SparseMatrices are created in a lazy fashion. <br/></td></tr>
<tr class="separator:ae5aba17776d02422e2d40bc44f420c3c inherit pub_types_classqcqpcpp_1_1_opt_problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a472411819883e4cbf7c826a3489626 inherit pub_types_classqcqpcpp_1_1_opt_problem"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6a472411819883e4cbf7c826a3489626"></a>
typedef Eigen::SparseVector<br class="typebreak"/>
&lt; <a class="el" href="classqcqpcpp_1_1_opt_problem.html#abefbee54ef45776816979486f4a34968">Scalar</a>, Eigen::RowMajor &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>SparseVector</b></td></tr>
<tr class="separator:a6a472411819883e4cbf7c826a3489626 inherit pub_types_classqcqpcpp_1_1_opt_problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a459f2a7adb112a97b5e358b969791a3a inherit pub_types_classqcqpcpp_1_1_opt_problem"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a459f2a7adb112a97b5e358b969791a3a"></a>
typedef Eigen::SparseMatrix<br class="typebreak"/>
&lt; <a class="el" href="classqcqpcpp_1_1_opt_problem.html#abefbee54ef45776816979486f4a34968">Scalar</a>, Eigen::RowMajor &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcqpcpp_1_1_opt_problem.html#a459f2a7adb112a97b5e358b969791a3a">SparseMatrix</a></td></tr>
<tr class="memdesc:a459f2a7adb112a97b5e358b969791a3a inherit pub_types_classqcqpcpp_1_1_opt_problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">To store quadratic objective (Q_o) and quadratic constraints (Qi). SparseMatrices are created in a lazy fashion. <br/></td></tr>
<tr class="separator:a459f2a7adb112a97b5e358b969791a3a inherit pub_types_classqcqpcpp_1_1_opt_problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a304b5fe236be1a31449e1ca6e78f0bf6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a304b5fe236be1a31449e1ca6e78f0bf6"></a>
virtual <a class="el" href="classqcqpcpp_1_1_mosek_opt.html#a98eacebd160a94e3baa64bad18c56c7e">ReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcqpcpp_1_1_mosek_opt.html#a304b5fe236be1a31449e1ca6e78f0bf6">update</a> (bool verbose=false) override</td></tr>
<tr class="memdesc:a304b5fe236be1a31449e1ca6e78f0bf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepare for optimization. Reads parent content and sets up specialized problem. Has to be called before <a class="el" href="classqcqpcpp_1_1_mosek_opt.html#a2f044aae8607b879959af0eab5b212e7" title="Run optimization using the current solver. MosekOpt::update() has to be called before. ">optimize()</a>. <br/></td></tr>
<tr class="separator:a304b5fe236be1a31449e1ca6e78f0bf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f044aae8607b879959af0eab5b212e7"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classqcqpcpp_1_1_mosek_opt.html#a98eacebd160a94e3baa64bad18c56c7e">ReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcqpcpp_1_1_mosek_opt.html#a2f044aae8607b879959af0eab5b212e7">optimize</a> (std::vector&lt; _Scalar &gt; *x_out=NULL, <a class="el" href="classqcqpcpp_1_1_opt_problem.html#a07145ca39acf400966c4a389cd3d0f11">OBJ_SENSE</a> objecitve_sense=OBJ_SENSE::MINIMIZE) override</td></tr>
<tr class="memdesc:a2f044aae8607b879959af0eab5b212e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run optimization using the current solver. <a class="el" href="classqcqpcpp_1_1_mosek_opt.html#a304b5fe236be1a31449e1ca6e78f0bf6" title="Prepare for optimization. Reads parent content and sets up specialized problem. Has to be called befo...">MosekOpt::update()</a> has to be called before.  <a href="#a2f044aae8607b879959af0eab5b212e7">More...</a><br/></td></tr>
<tr class="separator:a2f044aae8607b879959af0eab5b212e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3ddbb3cdc3d68af6657e4d6194f718f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab3ddbb3cdc3d68af6657e4d6194f718f"></a>
virtual <a class="el" href="classqcqpcpp_1_1_mosek_opt.html#adb2bcd596dc1d59d5e1de075957c02b3">Scalar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcqpcpp_1_1_mosek_opt.html#ab3ddbb3cdc3d68af6657e4d6194f718f">getINF</a> () const override</td></tr>
<tr class="memdesc:ab3ddbb3cdc3d68af6657e4d6194f718f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overrides infinity (default: std::numeric_limits&lt;Scalar&gt;::max()) to make implementation specific (i.e. here MSK_INFINITY == 1e30). <br/></td></tr>
<tr class="separator:ab3ddbb3cdc3d68af6657e4d6194f718f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc2205ee97221210be9965af00f5331c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adc2205ee97221210be9965af00f5331c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcqpcpp_1_1_mosek_opt.html#adc2205ee97221210be9965af00f5331c">MosekOpt</a> (MSKenv_t *env=NULL)</td></tr>
<tr class="memdesc:adc2205ee97221210be9965af00f5331c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Custom constructor taking optional Mosek environment as initialization.  env Optional parameter to pass already created Mosek environment. It is advised by Mosek to only have one environment, so if you have to instances, make sure you share the env. <br/></td></tr>
<tr class="separator:adc2205ee97221210be9965af00f5331c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3aea138100acd1150fc656b581ea94ba"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3aea138100acd1150fc656b581ea94ba"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcqpcpp_1_1_mosek_opt.html#a3aea138100acd1150fc656b581ea94ba">~MosekOpt</a> ()</td></tr>
<tr class="memdesc:a3aea138100acd1150fc656b581ea94ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual destructor. Frees the Mosek environment, if _ownsEnv is true. <br/></td></tr>
<tr class="separator:a3aea138100acd1150fc656b581ea94ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85a42771ff41ec84f42d00682d060713"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a85a42771ff41ec84f42d00682d060713"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcqpcpp_1_1_mosek_opt.html#a85a42771ff41ec84f42d00682d060713">MosekOpt</a> (<a class="el" href="classqcqpcpp_1_1_mosek_opt.html#af2179c57b18f865f2f20edee67a53d66">ParentType</a> const &amp;other)</td></tr>
<tr class="memdesc:a85a42771ff41ec84f42d00682d060713"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor. <br/></td></tr>
<tr class="separator:a85a42771ff41ec84f42d00682d060713"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4add50efb3ffc2b0c06be531abbf1cf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af4add50efb3ffc2b0c06be531abbf1cf"></a>
MSKenv_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcqpcpp_1_1_mosek_opt.html#af4add50efb3ffc2b0c06be531abbf1cf">getMosekEnv</a> () const </td></tr>
<tr class="memdesc:af4add50efb3ffc2b0c06be531abbf1cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mosek environment variable getter. <br/></td></tr>
<tr class="separator:af4add50efb3ffc2b0c06be531abbf1cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classqcqpcpp_1_1_opt_problem"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classqcqpcpp_1_1_opt_problem')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classqcqpcpp_1_1_opt_problem.html">qcqpcpp::OptProblem&lt; _Scalar &gt;</a></td></tr>
<tr class="memitem:ab6777a3e29c9180edbdcc9a732d73a10 inherit pub_methods_classqcqpcpp_1_1_opt_problem"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab6777a3e29c9180edbdcc9a732d73a10"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcqpcpp_1_1_opt_problem.html#ab6777a3e29c9180edbdcc9a732d73a10">OptProblem</a> ()</td></tr>
<tr class="memdesc:ab6777a3e29c9180edbdcc9a732d73a10 inherit pub_methods_classqcqpcpp_1_1_opt_problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor unused for the moment. Start with <em><a class="el" href="classqcqpcpp_1_1_opt_problem.html#a3c991323fb757cd93fcb89e84c662a3c" title="addVariable Start setting up the problem by defining the X vector. ">addVariable()</a></em>. <br/></td></tr>
<tr class="separator:ab6777a3e29c9180edbdcc9a732d73a10 inherit pub_methods_classqcqpcpp_1_1_opt_problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52f15e00cb72cbfab45dd3b28dbaccd4 inherit pub_methods_classqcqpcpp_1_1_opt_problem"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a52f15e00cb72cbfab45dd3b28dbaccd4"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcqpcpp_1_1_opt_problem.html#a52f15e00cb72cbfab45dd3b28dbaccd4">~OptProblem</a> ()</td></tr>
<tr class="memdesc:a52f15e00cb72cbfab45dd3b28dbaccd4 inherit pub_methods_classqcqpcpp_1_1_opt_problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor unused for the moment. Declared virtual for inheritence. <br/></td></tr>
<tr class="separator:a52f15e00cb72cbfab45dd3b28dbaccd4 inherit pub_methods_classqcqpcpp_1_1_opt_problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c991323fb757cd93fcb89e84c662a3c inherit pub_methods_classqcqpcpp_1_1_opt_problem"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcqpcpp_1_1_opt_problem.html#a3c991323fb757cd93fcb89e84c662a3c">addVariable</a> (<a class="el" href="classqcqpcpp_1_1_opt_problem.html#a3e82865d53426ef80b332476dd53a0c8">BOUND</a> bound_type=BOUND::FREE, <a class="el" href="classqcqpcpp_1_1_opt_problem.html#abefbee54ef45776816979486f4a34968">Scalar</a> lower_bound=-getINF(), <a class="el" href="classqcqpcpp_1_1_opt_problem.html#abefbee54ef45776816979486f4a34968">Scalar</a> upper_bound=+getINF(), <a class="el" href="classqcqpcpp_1_1_opt_problem.html#ae969d5bba7f88aedcc72d410fcb3db1b">VAR_TYPE</a> var_type=VAR_TYPE::CONTINUOUS, <a class="el" href="classqcqpcpp_1_1_opt_problem.html#a7f22877410f8de2172c59ef24d288e1a">LINEARITY</a> var_lin=LINEARITY::LINEAR)</td></tr>
<tr class="memdesc:a3c991323fb757cd93fcb89e84c662a3c inherit pub_methods_classqcqpcpp_1_1_opt_problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">addVariable Start setting up the problem by defining the X vector.  <a href="#a3c991323fb757cd93fcb89e84c662a3c">More...</a><br/></td></tr>
<tr class="separator:a3c991323fb757cd93fcb89e84c662a3c inherit pub_methods_classqcqpcpp_1_1_opt_problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad673bbc0064e15d2a52cff913b880827 inherit pub_methods_classqcqpcpp_1_1_opt_problem"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad673bbc0064e15d2a52cff913b880827"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>addVariable</b> (<a class="el" href="structqcqpcpp_1_1_opt_problem_1_1_variable.html">Variable</a> const &amp;var)</td></tr>
<tr class="separator:ad673bbc0064e15d2a52cff913b880827 inherit pub_methods_classqcqpcpp_1_1_opt_problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b9678b01b4d5a71f29d659e874d339d inherit pub_methods_classqcqpcpp_1_1_opt_problem"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0b9678b01b4d5a71f29d659e874d339d"></a>
<a class="el" href="classqcqpcpp_1_1_opt_problem.html#ae969d5bba7f88aedcc72d410fcb3db1b">VAR_TYPE</a> const&#160;</td><td class="memItemRight" valign="bottom"><b>getVarType</b> (int j) const </td></tr>
<tr class="separator:a0b9678b01b4d5a71f29d659e874d339d inherit pub_methods_classqcqpcpp_1_1_opt_problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75a18f9360d6982f747e418e2fd2781e inherit pub_methods_classqcqpcpp_1_1_opt_problem"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a75a18f9360d6982f747e418e2fd2781e"></a>
<a class="el" href="classqcqpcpp_1_1_opt_problem.html#a3e82865d53426ef80b332476dd53a0c8">BOUND</a> const&#160;</td><td class="memItemRight" valign="bottom"><b>getVarBoundType</b> (int j) const </td></tr>
<tr class="separator:a75a18f9360d6982f747e418e2fd2781e inherit pub_methods_classqcqpcpp_1_1_opt_problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32adbf0e2948565b4513a973e7daac6b inherit pub_methods_classqcqpcpp_1_1_opt_problem"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a32adbf0e2948565b4513a973e7daac6b"></a>
<a class="el" href="classqcqpcpp_1_1_opt_problem.html#abefbee54ef45776816979486f4a34968">Scalar</a> const&#160;</td><td class="memItemRight" valign="bottom"><b>getVarLowerBound</b> (int j) const </td></tr>
<tr class="separator:a32adbf0e2948565b4513a973e7daac6b inherit pub_methods_classqcqpcpp_1_1_opt_problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a709ead2013d55b0eba17a9bbb9aa7585 inherit pub_methods_classqcqpcpp_1_1_opt_problem"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a709ead2013d55b0eba17a9bbb9aa7585"></a>
<a class="el" href="classqcqpcpp_1_1_opt_problem.html#abefbee54ef45776816979486f4a34968">Scalar</a> const&#160;</td><td class="memItemRight" valign="bottom"><b>getVarUpperBound</b> (int j) const </td></tr>
<tr class="separator:a709ead2013d55b0eba17a9bbb9aa7585 inherit pub_methods_classqcqpcpp_1_1_opt_problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95324aee97cdd5df0fb1ef0076042ccd inherit pub_methods_classqcqpcpp_1_1_opt_problem"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a95324aee97cdd5df0fb1ef0076042ccd"></a>
<a class="el" href="classqcqpcpp_1_1_opt_problem.html#a7f22877410f8de2172c59ef24d288e1a">LINEARITY</a> const&#160;</td><td class="memItemRight" valign="bottom"><b>getVarLinearity</b> (int j) const </td></tr>
<tr class="separator:a95324aee97cdd5df0fb1ef0076042ccd inherit pub_methods_classqcqpcpp_1_1_opt_problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2d99c5704b37406191f4dec76957445 inherit pub_methods_classqcqpcpp_1_1_opt_problem"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae2d99c5704b37406191f4dec76957445"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcqpcpp_1_1_opt_problem.html#ae2d99c5704b37406191f4dec76957445">getVarCount</a> () const </td></tr>
<tr class="memdesc:ae2d99c5704b37406191f4dec76957445 inherit pub_methods_classqcqpcpp_1_1_opt_problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of variables currently in the system. <br/></td></tr>
<tr class="separator:ae2d99c5704b37406191f4dec76957445 inherit pub_methods_classqcqpcpp_1_1_opt_problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d332f4176e81dea1d7870dbbf63c2de inherit pub_methods_classqcqpcpp_1_1_opt_problem"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcqpcpp_1_1_opt_problem.html#a1d332f4176e81dea1d7870dbbf63c2de">setObjectiveBias</a> (<a class="el" href="classqcqpcpp_1_1_opt_problem.html#abefbee54ef45776816979486f4a34968">Scalar</a> cfix)</td></tr>
<tr class="memdesc:a1d332f4176e81dea1d7870dbbf63c2de inherit pub_methods_classqcqpcpp_1_1_opt_problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Formulation: minimize/maximize X' * 1/2 * Q_o * X + q_o * X + c.  <a href="#a1d332f4176e81dea1d7870dbbf63c2de">More...</a><br/></td></tr>
<tr class="separator:a1d332f4176e81dea1d7870dbbf63c2de inherit pub_methods_classqcqpcpp_1_1_opt_problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6ca4dab517c2b05fa9c925d5b375b56 inherit pub_methods_classqcqpcpp_1_1_opt_problem"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac6ca4dab517c2b05fa9c925d5b375b56"></a>
<a class="el" href="classqcqpcpp_1_1_opt_problem.html#abefbee54ef45776816979486f4a34968">Scalar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcqpcpp_1_1_opt_problem.html#ac6ca4dab517c2b05fa9c925d5b375b56">getObjectiveBias</a> () const </td></tr>
<tr class="memdesc:ac6ca4dab517c2b05fa9c925d5b375b56 inherit pub_methods_classqcqpcpp_1_1_opt_problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read-only getter for fixed objective function bias. <br/></td></tr>
<tr class="separator:ac6ca4dab517c2b05fa9c925d5b375b56 inherit pub_methods_classqcqpcpp_1_1_opt_problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ad2783576adda87ccd84969c610376c inherit pub_methods_classqcqpcpp_1_1_opt_problem"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5ad2783576adda87ccd84969c610376c"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcqpcpp_1_1_opt_problem.html#a5ad2783576adda87ccd84969c610376c">setLinObjective</a> (int j, <a class="el" href="classqcqpcpp_1_1_opt_problem.html#abefbee54ef45776816979486f4a34968">Scalar</a> coeff)</td></tr>
<tr class="memdesc:a5ad2783576adda87ccd84969c610376c inherit pub_methods_classqcqpcpp_1_1_opt_problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the j-th linear coefficient to coeff, regardless previous value. <br/></td></tr>
<tr class="separator:a5ad2783576adda87ccd84969c610376c inherit pub_methods_classqcqpcpp_1_1_opt_problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8297eee912b252970c08d3ab6ea0dd5c inherit pub_methods_classqcqpcpp_1_1_opt_problem"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8297eee912b252970c08d3ab6ea0dd5c"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>setLinObjectives</b> (Eigen::Matrix&lt; _Scalar,-1, 1 &gt; const &amp;obj)</td></tr>
<tr class="separator:a8297eee912b252970c08d3ab6ea0dd5c inherit pub_methods_classqcqpcpp_1_1_opt_problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e168efb985286ed67c4cd6e858c8361 inherit pub_methods_classqcqpcpp_1_1_opt_problem"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2e168efb985286ed67c4cd6e858c8361"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcqpcpp_1_1_opt_problem.html#a2e168efb985286ed67c4cd6e858c8361">addLinObjective</a> (int j, <a class="el" href="classqcqpcpp_1_1_opt_problem.html#abefbee54ef45776816979486f4a34968">Scalar</a> coeff)</td></tr>
<tr class="memdesc:a2e168efb985286ed67c4cd6e858c8361 inherit pub_methods_classqcqpcpp_1_1_opt_problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds coeff to the j-th linear coefficient. <br/></td></tr>
<tr class="separator:a2e168efb985286ed67c4cd6e858c8361 inherit pub_methods_classqcqpcpp_1_1_opt_problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a933f662bff5af9e2b2e9a6abb33f673f inherit pub_methods_classqcqpcpp_1_1_opt_problem"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a933f662bff5af9e2b2e9a6abb33f673f"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcqpcpp_1_1_opt_problem.html#a933f662bff5af9e2b2e9a6abb33f673f">addLinObjectives</a> (<a class="el" href="classqcqpcpp_1_1_opt_problem.html#a459f2a7adb112a97b5e358b969791a3a">SparseMatrix</a> const &amp;mx)</td></tr>
<tr class="memdesc:a933f662bff5af9e2b2e9a6abb33f673f inherit pub_methods_classqcqpcpp_1_1_opt_problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assumes vector input, so ((mx.cols == 1) || (mx.rows == 1)). <br/></td></tr>
<tr class="separator:a933f662bff5af9e2b2e9a6abb33f673f inherit pub_methods_classqcqpcpp_1_1_opt_problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c5568ecb1bb7c08541c6f62b7c81d92 inherit pub_methods_classqcqpcpp_1_1_opt_problem"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3c5568ecb1bb7c08541c6f62b7c81d92"></a>
std::vector&lt; <a class="el" href="classqcqpcpp_1_1_opt_problem.html#abefbee54ef45776816979486f4a34968">Scalar</a> &gt; const &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcqpcpp_1_1_opt_problem.html#a3c5568ecb1bb7c08541c6f62b7c81d92">getLinObjectives</a> () const </td></tr>
<tr class="memdesc:a3c5568ecb1bb7c08541c6f62b7c81d92 inherit pub_methods_classqcqpcpp_1_1_opt_problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read-only getter for linear objective vector. <br/></td></tr>
<tr class="separator:a3c5568ecb1bb7c08541c6f62b7c81d92 inherit pub_methods_classqcqpcpp_1_1_opt_problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e185ecac0718ed9c631a4c555b04044 inherit pub_methods_classqcqpcpp_1_1_opt_problem"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3e185ecac0718ed9c631a4c555b04044"></a>
<a class="el" href="classqcqpcpp_1_1_opt_problem.html#a459f2a7adb112a97b5e358b969791a3a">SparseMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcqpcpp_1_1_opt_problem.html#a3e185ecac0718ed9c631a4c555b04044">getLinObjectivesMatrix</a> () const </td></tr>
<tr class="memdesc:a3e185ecac0718ed9c631a4c555b04044 inherit pub_methods_classqcqpcpp_1_1_opt_problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a 1 column SparseMatrix temporary. <br/></td></tr>
<tr class="separator:a3e185ecac0718ed9c631a4c555b04044 inherit pub_methods_classqcqpcpp_1_1_opt_problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60c7bc7fbe9f009df84dc2e9d85cfc21 inherit pub_methods_classqcqpcpp_1_1_opt_problem"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a60c7bc7fbe9f009df84dc2e9d85cfc21"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcqpcpp_1_1_opt_problem.html#a60c7bc7fbe9f009df84dc2e9d85cfc21">addQObjective</a> (int i, int j, <a class="el" href="classqcqpcpp_1_1_opt_problem.html#abefbee54ef45776816979486f4a34968">Scalar</a> coeff)</td></tr>
<tr class="memdesc:a60c7bc7fbe9f009df84dc2e9d85cfc21 inherit pub_methods_classqcqpcpp_1_1_opt_problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds input to quadratic objective matrix, duplicate entries get summed in a lazy fashion (when <a class="el" href="classqcqpcpp_1_1_opt_problem.html#a1b0204e2d2b4925d90c17b6f0fa1b046" title="Make sure, to call before optimize is called, but AFTER the problem details are added using the sette...">update()</a> is called). <br/></td></tr>
<tr class="separator:a60c7bc7fbe9f009df84dc2e9d85cfc21 inherit pub_methods_classqcqpcpp_1_1_opt_problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad51fd4460e6d2e1a4fdc6efd93b35b48 inherit pub_methods_classqcqpcpp_1_1_opt_problem"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad51fd4460e6d2e1a4fdc6efd93b35b48"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcqpcpp_1_1_opt_problem.html#ad51fd4460e6d2e1a4fdc6efd93b35b48">addQObjectives</a> (<a class="el" href="classqcqpcpp_1_1_opt_problem.html#a459f2a7adb112a97b5e358b969791a3a">SparseMatrix</a> const &amp;mx)</td></tr>
<tr class="memdesc:ad51fd4460e6d2e1a4fdc6efd93b35b48 inherit pub_methods_classqcqpcpp_1_1_opt_problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds input matrix to quadratic objective matrix, duplicate entries get summed in a lazy fashion (when <a class="el" href="classqcqpcpp_1_1_opt_problem.html#a1b0204e2d2b4925d90c17b6f0fa1b046" title="Make sure, to call before optimize is called, but AFTER the problem details are added using the sette...">update()</a> is called). <br/></td></tr>
<tr class="separator:ad51fd4460e6d2e1a4fdc6efd93b35b48 inherit pub_methods_classqcqpcpp_1_1_opt_problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68e6761a829b1d658c58c5068a5fe3bc inherit pub_methods_classqcqpcpp_1_1_opt_problem"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a68e6761a829b1d658c58c5068a5fe3bc"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcqpcpp_1_1_opt_problem.html#a68e6761a829b1d658c58c5068a5fe3bc">setQObjectives</a> (<a class="el" href="classqcqpcpp_1_1_opt_problem.html#a459f2a7adb112a97b5e358b969791a3a">SparseMatrix</a> const &amp;mx)</td></tr>
<tr class="memdesc:a68e6761a829b1d658c58c5068a5fe3bc inherit pub_methods_classqcqpcpp_1_1_opt_problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears current objectives, and sets input as quadratic objective matrix. <br/></td></tr>
<tr class="separator:a68e6761a829b1d658c58c5068a5fe3bc inherit pub_methods_classqcqpcpp_1_1_opt_problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58a801d8f9e614ebadc3227d469c03b2 inherit pub_methods_classqcqpcpp_1_1_opt_problem"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a58a801d8f9e614ebadc3227d469c03b2"></a>
<a class="el" href="classqcqpcpp_1_1_opt_problem.html#ae5aba17776d02422e2d40bc44f420c3c">SparseEntries</a> const &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcqpcpp_1_1_opt_problem.html#a58a801d8f9e614ebadc3227d469c03b2">getQuadraticObjectives</a> () const </td></tr>
<tr class="memdesc:a58a801d8f9e614ebadc3227d469c03b2 inherit pub_methods_classqcqpcpp_1_1_opt_problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read-only getter for quadratic objective matrix's unordered entry set. <br/></td></tr>
<tr class="separator:a58a801d8f9e614ebadc3227d469c03b2 inherit pub_methods_classqcqpcpp_1_1_opt_problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0efe380fcca86a8836e5d5f3b871cb07 inherit pub_methods_classqcqpcpp_1_1_opt_problem"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0efe380fcca86a8836e5d5f3b871cb07"></a>
<a class="el" href="classqcqpcpp_1_1_opt_problem.html#a459f2a7adb112a97b5e358b969791a3a">SparseMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcqpcpp_1_1_opt_problem.html#a0efe380fcca86a8836e5d5f3b871cb07">getQuadraticObjectivesMatrix</a> () const </td></tr>
<tr class="memdesc:a0efe380fcca86a8836e5d5f3b871cb07 inherit pub_methods_classqcqpcpp_1_1_opt_problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns all Qo entries assembled to a Sparsematrix, temporarily. <br/></td></tr>
<tr class="separator:a0efe380fcca86a8836e5d5f3b871cb07 inherit pub_methods_classqcqpcpp_1_1_opt_problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a423286668e1af2bf9e3f34adc5fc4989 inherit pub_methods_classqcqpcpp_1_1_opt_problem"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classqcqpcpp_1_1_opt_problem.html#a459f2a7adb112a97b5e358b969791a3a">SparseMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcqpcpp_1_1_opt_problem.html#a423286668e1af2bf9e3f34adc5fc4989">estimateHessianOfLagrangian</a> () const </td></tr>
<tr class="memdesc:a423286668e1af2bf9e3f34adc5fc4989 inherit pub_methods_classqcqpcpp_1_1_opt_problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">estimateHessianOfLagrangian Estimates Hessian of Lagrangian from Quadratic objective matrix.  <a href="#a423286668e1af2bf9e3f34adc5fc4989">More...</a><br/></td></tr>
<tr class="separator:a423286668e1af2bf9e3f34adc5fc4989 inherit pub_methods_classqcqpcpp_1_1_opt_problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5aec3715a91e0ab78682f0757efa93cc inherit pub_methods_classqcqpcpp_1_1_opt_problem"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcqpcpp_1_1_opt_problem.html#a5aec3715a91e0ab78682f0757efa93cc">addConstraint</a> (<a class="el" href="classqcqpcpp_1_1_opt_problem.html#a3e82865d53426ef80b332476dd53a0c8">BOUND</a> bound_type, <a class="el" href="classqcqpcpp_1_1_opt_problem.html#abefbee54ef45776816979486f4a34968">Scalar</a> lower_bound, <a class="el" href="classqcqpcpp_1_1_opt_problem.html#abefbee54ef45776816979486f4a34968">Scalar</a> upper_bound, <a class="el" href="classqcqpcpp_1_1_opt_problem.html#a459f2a7adb112a97b5e358b969791a3a">SparseMatrix</a> *row_vector=NULL, <a class="el" href="classqcqpcpp_1_1_opt_problem.html#a7f22877410f8de2172c59ef24d288e1a">LINEARITY</a> c_lin=LINEARITY::LINEAR)</td></tr>
<tr class="memdesc:a5aec3715a91e0ab78682f0757efa93cc inherit pub_methods_classqcqpcpp_1_1_opt_problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append a constraint to the system, and optionally a linear line to the constraint matrix A. The line's row_id is the same, as the constr_id of the quadratic constraints.  <a href="#a5aec3715a91e0ab78682f0757efa93cc">More...</a><br/></td></tr>
<tr class="separator:a5aec3715a91e0ab78682f0757efa93cc inherit pub_methods_classqcqpcpp_1_1_opt_problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4321e8f6f761734692764bc44184a77 inherit pub_methods_classqcqpcpp_1_1_opt_problem"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae4321e8f6f761734692764bc44184a77"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>addConstraint</b> (<a class="el" href="structqcqpcpp_1_1_opt_problem_1_1_variable.html">Variable</a> const &amp;constr)</td></tr>
<tr class="separator:ae4321e8f6f761734692764bc44184a77 inherit pub_methods_classqcqpcpp_1_1_opt_problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fbb905d8c027137d5ef6694479ffd36 inherit pub_methods_classqcqpcpp_1_1_opt_problem"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9fbb905d8c027137d5ef6694479ffd36"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcqpcpp_1_1_opt_problem.html#a9fbb905d8c027137d5ef6694479ffd36">addLinConstraint</a> (<a class="el" href="classqcqpcpp_1_1_opt_problem.html#a3e82865d53426ef80b332476dd53a0c8">BOUND</a> bound_type, <a class="el" href="classqcqpcpp_1_1_opt_problem.html#abefbee54ef45776816979486f4a34968">Scalar</a> lower_bound, <a class="el" href="classqcqpcpp_1_1_opt_problem.html#abefbee54ef45776816979486f4a34968">Scalar</a> upper_bound, std::vector&lt; <a class="el" href="classqcqpcpp_1_1_opt_problem.html#abefbee54ef45776816979486f4a34968">Scalar</a> &gt; coeffs, <a class="el" href="classqcqpcpp_1_1_opt_problem.html#a7f22877410f8de2172c59ef24d288e1a">LINEARITY</a> c_lin=LINEARITY::LINEAR)</td></tr>
<tr class="memdesc:a9fbb905d8c027137d5ef6694479ffd36 inherit pub_methods_classqcqpcpp_1_1_opt_problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add linear constraint using an std::vector. <br/></td></tr>
<tr class="separator:a9fbb905d8c027137d5ef6694479ffd36 inherit pub_methods_classqcqpcpp_1_1_opt_problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34fa3b604ee1dd18222bce21e3c91d45 inherit pub_methods_classqcqpcpp_1_1_opt_problem"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a34fa3b604ee1dd18222bce21e3c91d45"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcqpcpp_1_1_opt_problem.html#a34fa3b604ee1dd18222bce21e3c91d45">addLinConstraints</a> (<a class="el" href="classqcqpcpp_1_1_opt_problem.html#a459f2a7adb112a97b5e358b969791a3a">SparseMatrix</a> const &amp;mx)</td></tr>
<tr class="memdesc:a34fa3b604ee1dd18222bce21e3c91d45 inherit pub_methods_classqcqpcpp_1_1_opt_problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds full linear constraint matrix. Please call addLinConstraint before. <br/></td></tr>
<tr class="separator:a34fa3b604ee1dd18222bce21e3c91d45 inherit pub_methods_classqcqpcpp_1_1_opt_problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefa72856a97c9eb1ca8d7081bd10ade6 inherit pub_methods_classqcqpcpp_1_1_opt_problem"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aefa72856a97c9eb1ca8d7081bd10ade6"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcqpcpp_1_1_opt_problem.html#aefa72856a97c9eb1ca8d7081bd10ade6">setLinConstraints</a> (<a class="el" href="classqcqpcpp_1_1_opt_problem.html#a459f2a7adb112a97b5e358b969791a3a">SparseMatrix</a> const &amp;mx)</td></tr>
<tr class="memdesc:aefa72856a97c9eb1ca8d7081bd10ade6 inherit pub_methods_classqcqpcpp_1_1_opt_problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets full linear constraint matrix, clears previous lin constraints. Please call addLinConstraint before. <br/></td></tr>
<tr class="separator:aefa72856a97c9eb1ca8d7081bd10ade6 inherit pub_methods_classqcqpcpp_1_1_opt_problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af51ed311c74988d23c8b06df09b00de4 inherit pub_methods_classqcqpcpp_1_1_opt_problem"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af51ed311c74988d23c8b06df09b00de4"></a>
<a class="el" href="classqcqpcpp_1_1_opt_problem.html#a3e82865d53426ef80b332476dd53a0c8">BOUND</a> const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcqpcpp_1_1_opt_problem.html#af51ed311c74988d23c8b06df09b00de4">getConstraintBoundType</a> (int i) const </td></tr>
<tr class="memdesc:af51ed311c74988d23c8b06df09b00de4 inherit pub_methods_classqcqpcpp_1_1_opt_problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns bound type of i-th constraint (free, lower, upper, range, fixed). <br/></td></tr>
<tr class="separator:af51ed311c74988d23c8b06df09b00de4 inherit pub_methods_classqcqpcpp_1_1_opt_problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0cc5de94df55478c09bd222d06bb856 inherit pub_methods_classqcqpcpp_1_1_opt_problem"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af0cc5de94df55478c09bd222d06bb856"></a>
<a class="el" href="classqcqpcpp_1_1_opt_problem.html#abefbee54ef45776816979486f4a34968">Scalar</a> const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcqpcpp_1_1_opt_problem.html#af0cc5de94df55478c09bd222d06bb856">getConstraintLowerBound</a> (int i) const </td></tr>
<tr class="memdesc:af0cc5de94df55478c09bd222d06bb856 inherit pub_methods_classqcqpcpp_1_1_opt_problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns lower bound of i-th constraint. <br/></td></tr>
<tr class="separator:af0cc5de94df55478c09bd222d06bb856 inherit pub_methods_classqcqpcpp_1_1_opt_problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9750a17c5fd5c1377fabf76930c47f9d inherit pub_methods_classqcqpcpp_1_1_opt_problem"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9750a17c5fd5c1377fabf76930c47f9d"></a>
<a class="el" href="classqcqpcpp_1_1_opt_problem.html#abefbee54ef45776816979486f4a34968">Scalar</a> const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcqpcpp_1_1_opt_problem.html#a9750a17c5fd5c1377fabf76930c47f9d">getConstraintUpperBound</a> (int i) const </td></tr>
<tr class="memdesc:a9750a17c5fd5c1377fabf76930c47f9d inherit pub_methods_classqcqpcpp_1_1_opt_problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns upper bound of i-th constraint. <br/></td></tr>
<tr class="separator:a9750a17c5fd5c1377fabf76930c47f9d inherit pub_methods_classqcqpcpp_1_1_opt_problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cd95cd4b68aa7fc7fcb40b6cd7f3256 inherit pub_methods_classqcqpcpp_1_1_opt_problem"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6cd95cd4b68aa7fc7fcb40b6cd7f3256"></a>
<a class="el" href="classqcqpcpp_1_1_opt_problem.html#a7f22877410f8de2172c59ef24d288e1a">LINEARITY</a> const&#160;</td><td class="memItemRight" valign="bottom"><b>getConstraintLinearity</b> (int j) const </td></tr>
<tr class="separator:a6cd95cd4b68aa7fc7fcb40b6cd7f3256 inherit pub_methods_classqcqpcpp_1_1_opt_problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9ff1a5e53a292f9655faf3d107e1fa6 inherit pub_methods_classqcqpcpp_1_1_opt_problem"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad9ff1a5e53a292f9655faf3d107e1fa6"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcqpcpp_1_1_opt_problem.html#ad9ff1a5e53a292f9655faf3d107e1fa6">getConstraintCount</a> () const </td></tr>
<tr class="memdesc:ad9ff1a5e53a292f9655faf3d107e1fa6 inherit pub_methods_classqcqpcpp_1_1_opt_problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of linear constraint lines currently in the system. <br/></td></tr>
<tr class="separator:ad9ff1a5e53a292f9655faf3d107e1fa6 inherit pub_methods_classqcqpcpp_1_1_opt_problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab57d341de611ac5a561bdd0268e17c2 inherit pub_methods_classqcqpcpp_1_1_opt_problem"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aab57d341de611ac5a561bdd0268e17c2"></a>
<a class="el" href="classqcqpcpp_1_1_opt_problem.html#a459f2a7adb112a97b5e358b969791a3a">SparseMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><b>estimateJacobianOfConstraints</b> () const </td></tr>
<tr class="separator:aab57d341de611ac5a561bdd0268e17c2 inherit pub_methods_classqcqpcpp_1_1_opt_problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07a1e000c6e16ea63ae107f7b266bb2e inherit pub_methods_classqcqpcpp_1_1_opt_problem"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcqpcpp_1_1_opt_problem.html#a07a1e000c6e16ea63ae107f7b266bb2e">addQConstraint</a> (int constr_id, int i, int j, <a class="el" href="classqcqpcpp_1_1_opt_problem.html#abefbee54ef45776816979486f4a34968">Scalar</a> coeff)</td></tr>
<tr class="memdesc:a07a1e000c6e16ea63ae107f7b266bb2e inherit pub_methods_classqcqpcpp_1_1_opt_problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">addQConstraint Append an entry to a quadratic constraint matrix. Duplicate entries are summed in a lazy fashion (when <em><a class="el" href="classqcqpcpp_1_1_opt_problem.html#a1b0204e2d2b4925d90c17b6f0fa1b046" title="Make sure, to call before optimize is called, but AFTER the problem details are added using the sette...">update()</a></em>) is called.  <a href="#a07a1e000c6e16ea63ae107f7b266bb2e">More...</a><br/></td></tr>
<tr class="separator:a07a1e000c6e16ea63ae107f7b266bb2e inherit pub_methods_classqcqpcpp_1_1_opt_problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3651a692715bc99a82d76428e250133a inherit pub_methods_classqcqpcpp_1_1_opt_problem"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3651a692715bc99a82d76428e250133a"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>addQConstraints</b> (<a class="el" href="classqcqpcpp_1_1_opt_problem.html#a459f2a7adb112a97b5e358b969791a3a">SparseMatrix</a> const &amp;mx)</td></tr>
<tr class="separator:a3651a692715bc99a82d76428e250133a inherit pub_methods_classqcqpcpp_1_1_opt_problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8da6d9fbbe10f1f25436ff0f33a0cd87 inherit pub_methods_classqcqpcpp_1_1_opt_problem"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8da6d9fbbe10f1f25436ff0f33a0cd87"></a>
<a class="el" href="classqcqpcpp_1_1_opt_problem.html#ae5aba17776d02422e2d40bc44f420c3c">SparseEntries</a> const &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcqpcpp_1_1_opt_problem.html#a8da6d9fbbe10f1f25436ff0f33a0cd87">getLinConstraints</a> () const </td></tr>
<tr class="memdesc:a8da6d9fbbe10f1f25436ff0f33a0cd87 inherit pub_methods_classqcqpcpp_1_1_opt_problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns all A entries, unordered. <br/></td></tr>
<tr class="separator:a8da6d9fbbe10f1f25436ff0f33a0cd87 inherit pub_methods_classqcqpcpp_1_1_opt_problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4461ed8cb57e8fde3bcb9a8bb6be1c46 inherit pub_methods_classqcqpcpp_1_1_opt_problem"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4461ed8cb57e8fde3bcb9a8bb6be1c46"></a>
<a class="el" href="classqcqpcpp_1_1_opt_problem.html#a459f2a7adb112a97b5e358b969791a3a">SparseMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcqpcpp_1_1_opt_problem.html#a4461ed8cb57e8fde3bcb9a8bb6be1c46">getLinConstraintsMatrix</a> () const </td></tr>
<tr class="memdesc:a4461ed8cb57e8fde3bcb9a8bb6be1c46 inherit pub_methods_classqcqpcpp_1_1_opt_problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns all A entries assembled to a Sparsematrix, temporarily. <br/></td></tr>
<tr class="separator:a4461ed8cb57e8fde3bcb9a8bb6be1c46 inherit pub_methods_classqcqpcpp_1_1_opt_problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af36f03cada7e42f75dd4790e282b1cb3 inherit pub_methods_classqcqpcpp_1_1_opt_problem"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af36f03cada7e42f75dd4790e282b1cb3"></a>
<a class="el" href="classqcqpcpp_1_1_opt_problem.html#ae5aba17776d02422e2d40bc44f420c3c">SparseEntries</a> const &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcqpcpp_1_1_opt_problem.html#af36f03cada7e42f75dd4790e282b1cb3">getQuadraticConstraints</a> (int i) const </td></tr>
<tr class="memdesc:af36f03cada7e42f75dd4790e282b1cb3 inherit pub_methods_classqcqpcpp_1_1_opt_problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns all Qi entries, unordered. <br/></td></tr>
<tr class="separator:af36f03cada7e42f75dd4790e282b1cb3 inherit pub_methods_classqcqpcpp_1_1_opt_problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26a0fca5c19d8d4b39509b285d46da61 inherit pub_methods_classqcqpcpp_1_1_opt_problem"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a26a0fca5c19d8d4b39509b285d46da61"></a>
std::vector&lt; <a class="el" href="classqcqpcpp_1_1_opt_problem.html#ae5aba17776d02422e2d40bc44f420c3c">SparseEntries</a> &gt;<br class="typebreak"/>
 const &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcqpcpp_1_1_opt_problem.html#a26a0fca5c19d8d4b39509b285d46da61">getQuadraticConstraints</a> () const </td></tr>
<tr class="memdesc:a26a0fca5c19d8d4b39509b285d46da61 inherit pub_methods_classqcqpcpp_1_1_opt_problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns vector of Qi entries, vector is ordered by i, but the entries are unordered. <br/></td></tr>
<tr class="separator:a26a0fca5c19d8d4b39509b285d46da61 inherit pub_methods_classqcqpcpp_1_1_opt_problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb318653314271b892d6d013634015b8 inherit pub_methods_classqcqpcpp_1_1_opt_problem"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abb318653314271b892d6d013634015b8"></a>
<a class="el" href="classqcqpcpp_1_1_opt_problem.html#a459f2a7adb112a97b5e358b969791a3a">SparseMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcqpcpp_1_1_opt_problem.html#abb318653314271b892d6d013634015b8">getQuadraticConstraintsMatrix</a> (int i) const </td></tr>
<tr class="memdesc:abb318653314271b892d6d013634015b8 inherit pub_methods_classqcqpcpp_1_1_opt_problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns all Qi entries assembled to a Sparsematrix, temporarily. <br/></td></tr>
<tr class="separator:abb318653314271b892d6d013634015b8 inherit pub_methods_classqcqpcpp_1_1_opt_problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a924e208319a9c781cb1ca406570da17f inherit pub_methods_classqcqpcpp_1_1_opt_problem"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a924e208319a9c781cb1ca406570da17f"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcqpcpp_1_1_opt_problem.html#a924e208319a9c781cb1ca406570da17f">printProblem</a> () const </td></tr>
<tr class="memdesc:a924e208319a9c781cb1ca406570da17f inherit pub_methods_classqcqpcpp_1_1_opt_problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints inner state before optimization. <br/></td></tr>
<tr class="separator:a924e208319a9c781cb1ca406570da17f inherit pub_methods_classqcqpcpp_1_1_opt_problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a359adde2337253cfe6e467154c11d765 inherit pub_methods_classqcqpcpp_1_1_opt_problem"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a359adde2337253cfe6e467154c11d765"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcqpcpp_1_1_opt_problem.html#a359adde2337253cfe6e467154c11d765">setSolution</a> (<a class="el" href="classqcqpcpp_1_1_opt_problem.html#a00fc3821814ec59c74df4a47467b0eb7">VectorX</a> const &amp;sol)</td></tr>
<tr class="memdesc:a359adde2337253cfe6e467154c11d765 inherit pub_methods_classqcqpcpp_1_1_opt_problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setter to store latest solution, to be called from <a class="el" href="classqcqpcpp_1_1_opt_problem.html#a5f297f555fb0ac17e7512c92efc02a1a" title="Call to run optimization, AFTER the problem details were added, and update() was called. ">optimize()</a>. <br/></td></tr>
<tr class="separator:a359adde2337253cfe6e467154c11d765 inherit pub_methods_classqcqpcpp_1_1_opt_problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae7cf99dc6ffdf8f49d396c995350916 inherit pub_methods_classqcqpcpp_1_1_opt_problem"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aae7cf99dc6ffdf8f49d396c995350916"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcqpcpp_1_1_opt_problem.html#aae7cf99dc6ffdf8f49d396c995350916">write</a> (std::string const &amp;path) const </td></tr>
<tr class="memdesc:aae7cf99dc6ffdf8f49d396c995350916 inherit pub_methods_classqcqpcpp_1_1_opt_problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialize to disk. <br/></td></tr>
<tr class="separator:aae7cf99dc6ffdf8f49d396c995350916 inherit pub_methods_classqcqpcpp_1_1_opt_problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a714931619f6f1f151f143fb3f885c34b inherit pub_methods_classqcqpcpp_1_1_opt_problem"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a714931619f6f1f151f143fb3f885c34b"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcqpcpp_1_1_opt_problem.html#a714931619f6f1f151f143fb3f885c34b">read</a> (std::string const &amp;proj_path)</td></tr>
<tr class="memdesc:a714931619f6f1f151f143fb3f885c34b inherit pub_methods_classqcqpcpp_1_1_opt_problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read from disk. <br/></td></tr>
<tr class="separator:a714931619f6f1f151f143fb3f885c34b inherit pub_methods_classqcqpcpp_1_1_opt_problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a2c1c18429d8e90827d765c268b1a2c7f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2c1c18429d8e90827d765c268b1a2c7f"></a>
static MSKboundkeye&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcqpcpp_1_1_mosek_opt.html#a2c1c18429d8e90827d765c268b1a2c7f">getBoundTypeCustom</a> (typename <a class="el" href="classqcqpcpp_1_1_opt_problem.html#a3e82865d53426ef80b332476dd53a0c8">ParentType::BOUND</a> bound)</td></tr>
<tr class="memdesc:a2c1c18429d8e90827d765c268b1a2c7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts <a class="el" href="classqcqpcpp_1_1_opt_problem.html#a3e82865d53426ef80b332476dd53a0c8">OptProblem::BOUND</a> to mosek bound type (MSK_BK_*). <br/></td></tr>
<tr class="separator:a2c1c18429d8e90827d765c268b1a2c7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cb6b0ff4ad67e493e74a9b92f22f9cd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1cb6b0ff4ad67e493e74a9b92f22f9cd"></a>
static MSKvariabletypee&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcqpcpp_1_1_mosek_opt.html#a1cb6b0ff4ad67e493e74a9b92f22f9cd">getVarTypeCustom</a> (typename <a class="el" href="classqcqpcpp_1_1_opt_problem.html#ae969d5bba7f88aedcc72d410fcb3db1b">ParentType::VAR_TYPE</a> var_type)</td></tr>
<tr class="memdesc:a1cb6b0ff4ad67e493e74a9b92f22f9cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts <a class="el" href="classqcqpcpp_1_1_opt_problem.html#ae969d5bba7f88aedcc72d410fcb3db1b">OptProblem::VAR_TYPE</a> to mosek var type (MSK_VAR_TYPE_CONT, MSK_VAR_TYPE_INT). <br/></td></tr>
<tr class="separator:a1cb6b0ff4ad67e493e74a9b92f22f9cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a3167dd46337b175c8e696e8fd6bef99a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3167dd46337b175c8e696e8fd6bef99a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcqpcpp_1_1_mosek_opt.html#a3167dd46337b175c8e696e8fd6bef99a">_storeSolution</a> (double *xx, int n)</td></tr>
<tr class="memdesc:a3167dd46337b175c8e696e8fd6bef99a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classqcqpcpp_1_1_mosek_opt.html#a2f044aae8607b879959af0eab5b212e7" title="Run optimization using the current solver. MosekOpt::update() has to be called before. ">MosekOpt::optimize()</a> calls this to store output in <a class="el" href="classqcqpcpp_1_1_opt_problem.html#a821de12c61fdcd509910c50e8c5db3fc" title="Optimize() stores the solution here when finishing. ">OptProblem::_x</a>. <br/></td></tr>
<tr class="separator:a3167dd46337b175c8e696e8fd6bef99a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefbdb526a47dc206a8b35befa66eac53"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aefbdb526a47dc206a8b35befa66eac53"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcqpcpp_1_1_mosek_opt.html#aefbdb526a47dc206a8b35befa66eac53">_init</a> (MSKenv_t *env)</td></tr>
<tr class="memdesc:aefbdb526a47dc206a8b35befa66eac53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instance init. Should be called from all constructors. <br/></td></tr>
<tr class="separator:aefbdb526a47dc206a8b35befa66eac53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classqcqpcpp_1_1_opt_problem"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classqcqpcpp_1_1_opt_problem')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classqcqpcpp_1_1_opt_problem.html">qcqpcpp::OptProblem&lt; _Scalar &gt;</a></td></tr>
<tr class="memitem:a18decfa6834215497322df2356eb58e6 inherit pro_methods_classqcqpcpp_1_1_opt_problem"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a18decfa6834215497322df2356eb58e6"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>getAuxName</b> () const </td></tr>
<tr class="separator:a18decfa6834215497322df2356eb58e6 inherit pro_methods_classqcqpcpp_1_1_opt_problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43b4e8db96917afc0c01128ee14d50da inherit pro_methods_classqcqpcpp_1_1_opt_problem"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a43b4e8db96917afc0c01128ee14d50da"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>getqoName</b> () const </td></tr>
<tr class="separator:a43b4e8db96917afc0c01128ee14d50da inherit pro_methods_classqcqpcpp_1_1_opt_problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83a76e1a5a9cf0287102685977705699 inherit pro_methods_classqcqpcpp_1_1_opt_problem"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a83a76e1a5a9cf0287102685977705699"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>getQoName</b> () const </td></tr>
<tr class="separator:a83a76e1a5a9cf0287102685977705699 inherit pro_methods_classqcqpcpp_1_1_opt_problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdd1b2cca210282c8934c530ac16d76c inherit pro_methods_classqcqpcpp_1_1_opt_problem"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acdd1b2cca210282c8934c530ac16d76c"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>getAName</b> () const </td></tr>
<tr class="separator:acdd1b2cca210282c8934c530ac16d76c inherit pro_methods_classqcqpcpp_1_1_opt_problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afea4d58d7fac7c8d7f26d7adf05c19b1 inherit pro_methods_classqcqpcpp_1_1_opt_problem"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afea4d58d7fac7c8d7f26d7adf05c19b1"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>getQiName</b> (int i) const </td></tr>
<tr class="separator:afea4d58d7fac7c8d7f26d7adf05c19b1 inherit pro_methods_classqcqpcpp_1_1_opt_problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01f97a8eaca399327de2fae23a6f5acb inherit pro_methods_classqcqpcpp_1_1_opt_problem"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a01f97a8eaca399327de2fae23a6f5acb"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>_parseAuxFile</b> (std::string const &amp;aux_file_path)</td></tr>
<tr class="separator:a01f97a8eaca399327de2fae23a6f5acb inherit pro_methods_classqcqpcpp_1_1_opt_problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a85297e905a06358c6ef9047d4781c779"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a85297e905a06358c6ef9047d4781c779"></a>
MSKrescodee&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcqpcpp_1_1_mosek_opt.html#a85297e905a06358c6ef9047d4781c779">_r</a></td></tr>
<tr class="memdesc:a85297e905a06358c6ef9047d4781c779"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mosek error code for operation calls. <br/></td></tr>
<tr class="separator:a85297e905a06358c6ef9047d4781c779"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae70f646d8d52b3dbe91229577209d249"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae70f646d8d52b3dbe91229577209d249"></a>
MSKenv_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcqpcpp_1_1_mosek_opt.html#ae70f646d8d52b3dbe91229577209d249">_env</a></td></tr>
<tr class="memdesc:ae70f646d8d52b3dbe91229577209d249"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mosek environment variable containing all problems. Make sure to only have one of these, and share between instances of <a class="el" href="classqcqpcpp_1_1_mosek_opt.html" title="Specialization of optimisation problem to solve using the Mosek solver. ">MosekOpt</a>. <br/></td></tr>
<tr class="separator:ae70f646d8d52b3dbe91229577209d249"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae40498a2e0b4e3287f259c8323514855"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae40498a2e0b4e3287f259c8323514855"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcqpcpp_1_1_mosek_opt.html#ae40498a2e0b4e3287f259c8323514855">_ownsEnv</a></td></tr>
<tr class="memdesc:ae40498a2e0b4e3287f259c8323514855"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shows, if this instance is the one that has to free the Mosek environment in the end. <br/></td></tr>
<tr class="separator:ae40498a2e0b4e3287f259c8323514855"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0d0de3e43315367b361a5cf47b83f93"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa0d0de3e43315367b361a5cf47b83f93"></a>
MSKtask_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcqpcpp_1_1_mosek_opt.html#aa0d0de3e43315367b361a5cf47b83f93">_task</a></td></tr>
<tr class="memdesc:aa0d0de3e43315367b361a5cf47b83f93"><td class="mdescLeft">&#160;</td><td class="mdescRight">One "Problem" in Mosek. <br/></td></tr>
<tr class="separator:aa0d0de3e43315367b361a5cf47b83f93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classqcqpcpp_1_1_opt_problem"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classqcqpcpp_1_1_opt_problem')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classqcqpcpp_1_1_opt_problem.html">qcqpcpp::OptProblem&lt; _Scalar &gt;</a></td></tr>
<tr class="memitem:a28d286500ef61cf95e5a04a543fe0274 inherit pro_attribs_classqcqpcpp_1_1_opt_problem"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a28d286500ef61cf95e5a04a543fe0274"></a>
std::vector&lt; <a class="el" href="classqcqpcpp_1_1_opt_problem.html#a3e82865d53426ef80b332476dd53a0c8">BOUND</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcqpcpp_1_1_opt_problem.html#a28d286500ef61cf95e5a04a543fe0274">_bkx</a></td></tr>
<tr class="memdesc:a28d286500ef61cf95e5a04a543fe0274 inherit pro_attribs_classqcqpcpp_1_1_opt_problem"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structqcqpcpp_1_1_opt_problem_1_1_variable.html" title="Internal structure to store a variable. ">Variable</a> bound keys. <br/></td></tr>
<tr class="separator:a28d286500ef61cf95e5a04a543fe0274 inherit pro_attribs_classqcqpcpp_1_1_opt_problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7948ee2092c3ff635615e6fe7391ed06 inherit pro_attribs_classqcqpcpp_1_1_opt_problem"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7948ee2092c3ff635615e6fe7391ed06"></a>
std::vector&lt; <a class="el" href="classqcqpcpp_1_1_opt_problem.html#abefbee54ef45776816979486f4a34968">Scalar</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcqpcpp_1_1_opt_problem.html#a7948ee2092c3ff635615e6fe7391ed06">_blx</a></td></tr>
<tr class="memdesc:a7948ee2092c3ff635615e6fe7391ed06 inherit pro_attribs_classqcqpcpp_1_1_opt_problem"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structqcqpcpp_1_1_opt_problem_1_1_variable.html" title="Internal structure to store a variable. ">Variable</a> numerical value of lower bounds. <br/></td></tr>
<tr class="separator:a7948ee2092c3ff635615e6fe7391ed06 inherit pro_attribs_classqcqpcpp_1_1_opt_problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad58f9509bb0c9d863fd3d02e3da1b701 inherit pro_attribs_classqcqpcpp_1_1_opt_problem"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad58f9509bb0c9d863fd3d02e3da1b701"></a>
std::vector&lt; <a class="el" href="classqcqpcpp_1_1_opt_problem.html#abefbee54ef45776816979486f4a34968">Scalar</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcqpcpp_1_1_opt_problem.html#ad58f9509bb0c9d863fd3d02e3da1b701">_bux</a></td></tr>
<tr class="memdesc:ad58f9509bb0c9d863fd3d02e3da1b701 inherit pro_attribs_classqcqpcpp_1_1_opt_problem"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structqcqpcpp_1_1_opt_problem_1_1_variable.html" title="Internal structure to store a variable. ">Variable</a> numerical value of upper bounds. <br/></td></tr>
<tr class="separator:ad58f9509bb0c9d863fd3d02e3da1b701 inherit pro_attribs_classqcqpcpp_1_1_opt_problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9b8fad5dff911f317d3249abe5a2240 inherit pro_attribs_classqcqpcpp_1_1_opt_problem"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad9b8fad5dff911f317d3249abe5a2240"></a>
std::vector&lt; <a class="el" href="classqcqpcpp_1_1_opt_problem.html#ae969d5bba7f88aedcc72d410fcb3db1b">VAR_TYPE</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcqpcpp_1_1_opt_problem.html#ad9b8fad5dff911f317d3249abe5a2240">_type_x</a></td></tr>
<tr class="memdesc:ad9b8fad5dff911f317d3249abe5a2240 inherit pro_attribs_classqcqpcpp_1_1_opt_problem"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structqcqpcpp_1_1_opt_problem_1_1_variable.html" title="Internal structure to store a variable. ">Variable</a> type. <br/></td></tr>
<tr class="separator:ad9b8fad5dff911f317d3249abe5a2240 inherit pro_attribs_classqcqpcpp_1_1_opt_problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7894d293daeadeb9f3de489c4352f824 inherit pro_attribs_classqcqpcpp_1_1_opt_problem"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7894d293daeadeb9f3de489c4352f824"></a>
std::vector&lt; <a class="el" href="classqcqpcpp_1_1_opt_problem.html#a7f22877410f8de2172c59ef24d288e1a">LINEARITY</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcqpcpp_1_1_opt_problem.html#a7894d293daeadeb9f3de489c4352f824">_lin_x</a></td></tr>
<tr class="memdesc:a7894d293daeadeb9f3de489c4352f824 inherit pro_attribs_classqcqpcpp_1_1_opt_problem"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structqcqpcpp_1_1_opt_problem_1_1_variable.html" title="Internal structure to store a variable. ">Variable</a> linearity. <br/></td></tr>
<tr class="separator:a7894d293daeadeb9f3de489c4352f824 inherit pro_attribs_classqcqpcpp_1_1_opt_problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1a21c5cfe645d326651dfa0fd3f8c09 inherit pro_attribs_classqcqpcpp_1_1_opt_problem"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad1a21c5cfe645d326651dfa0fd3f8c09"></a>
<a class="el" href="classqcqpcpp_1_1_opt_problem.html#abefbee54ef45776816979486f4a34968">Scalar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcqpcpp_1_1_opt_problem.html#ad1a21c5cfe645d326651dfa0fd3f8c09">_cfix</a></td></tr>
<tr class="memdesc:ad1a21c5cfe645d326651dfa0fd3f8c09 inherit pro_attribs_classqcqpcpp_1_1_opt_problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant bias to objective function (c) <br/></td></tr>
<tr class="separator:ad1a21c5cfe645d326651dfa0fd3f8c09 inherit pro_attribs_classqcqpcpp_1_1_opt_problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ad7b322ca5cd903759233909ac5370c inherit pro_attribs_classqcqpcpp_1_1_opt_problem"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4ad7b322ca5cd903759233909ac5370c"></a>
std::vector&lt; <a class="el" href="classqcqpcpp_1_1_opt_problem.html#abefbee54ef45776816979486f4a34968">Scalar</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcqpcpp_1_1_opt_problem.html#a4ad7b322ca5cd903759233909ac5370c">_linObjs</a></td></tr>
<tr class="memdesc:a4ad7b322ca5cd903759233909ac5370c inherit pro_attribs_classqcqpcpp_1_1_opt_problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linear variable coeffs (objective function) (q_o) <br/></td></tr>
<tr class="separator:a4ad7b322ca5cd903759233909ac5370c inherit pro_attribs_classqcqpcpp_1_1_opt_problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51ab516cc5a7496aaf5489dd81ec632a inherit pro_attribs_classqcqpcpp_1_1_opt_problem"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a51ab516cc5a7496aaf5489dd81ec632a"></a>
<a class="el" href="classqcqpcpp_1_1_opt_problem.html#ae5aba17776d02422e2d40bc44f420c3c">SparseEntries</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcqpcpp_1_1_opt_problem.html#a51ab516cc5a7496aaf5489dd81ec632a">_quadObjList</a></td></tr>
<tr class="memdesc:a51ab516cc5a7496aaf5489dd81ec632a inherit pro_attribs_classqcqpcpp_1_1_opt_problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accumulator for QObjective values (Q_o) <br/></td></tr>
<tr class="separator:a51ab516cc5a7496aaf5489dd81ec632a inherit pro_attribs_classqcqpcpp_1_1_opt_problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4cdfde255e560275b7b10a3efdd8e87 inherit pro_attribs_classqcqpcpp_1_1_opt_problem"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad4cdfde255e560275b7b10a3efdd8e87"></a>
std::vector&lt; <a class="el" href="classqcqpcpp_1_1_opt_problem.html#a3e82865d53426ef80b332476dd53a0c8">BOUND</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcqpcpp_1_1_opt_problem.html#ad4cdfde255e560275b7b10a3efdd8e87">_bkc</a></td></tr>
<tr class="memdesc:ad4cdfde255e560275b7b10a3efdd8e87 inherit pro_attribs_classqcqpcpp_1_1_opt_problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraints bound keys. <br/></td></tr>
<tr class="separator:ad4cdfde255e560275b7b10a3efdd8e87 inherit pro_attribs_classqcqpcpp_1_1_opt_problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac25092c53254dc08686c9f8d6a52292e inherit pro_attribs_classqcqpcpp_1_1_opt_problem"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac25092c53254dc08686c9f8d6a52292e"></a>
std::vector&lt; <a class="el" href="classqcqpcpp_1_1_opt_problem.html#abefbee54ef45776816979486f4a34968">Scalar</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcqpcpp_1_1_opt_problem.html#ac25092c53254dc08686c9f8d6a52292e">_blc</a></td></tr>
<tr class="memdesc:ac25092c53254dc08686c9f8d6a52292e inherit pro_attribs_classqcqpcpp_1_1_opt_problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraints numerical value of lower bounds. <br/></td></tr>
<tr class="separator:ac25092c53254dc08686c9f8d6a52292e inherit pro_attribs_classqcqpcpp_1_1_opt_problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b405a08d1aa49ba02c159d0969ee784 inherit pro_attribs_classqcqpcpp_1_1_opt_problem"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6b405a08d1aa49ba02c159d0969ee784"></a>
std::vector&lt; <a class="el" href="classqcqpcpp_1_1_opt_problem.html#abefbee54ef45776816979486f4a34968">Scalar</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcqpcpp_1_1_opt_problem.html#a6b405a08d1aa49ba02c159d0969ee784">_buc</a></td></tr>
<tr class="memdesc:a6b405a08d1aa49ba02c159d0969ee784 inherit pro_attribs_classqcqpcpp_1_1_opt_problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraints numerical value of upper bounds. <br/></td></tr>
<tr class="separator:a6b405a08d1aa49ba02c159d0969ee784 inherit pro_attribs_classqcqpcpp_1_1_opt_problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad46cd1443d7a8d0d66cb396bed1840fd inherit pro_attribs_classqcqpcpp_1_1_opt_problem"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad46cd1443d7a8d0d66cb396bed1840fd"></a>
std::vector&lt; <a class="el" href="classqcqpcpp_1_1_opt_problem.html#a7f22877410f8de2172c59ef24d288e1a">LINEARITY</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcqpcpp_1_1_opt_problem.html#ad46cd1443d7a8d0d66cb396bed1840fd">_lin_c</a></td></tr>
<tr class="memdesc:ad46cd1443d7a8d0d66cb396bed1840fd inherit pro_attribs_classqcqpcpp_1_1_opt_problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraints linearity. <br/></td></tr>
<tr class="separator:ad46cd1443d7a8d0d66cb396bed1840fd inherit pro_attribs_classqcqpcpp_1_1_opt_problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc648955f1b21310973857e573c0b4ea inherit pro_attribs_classqcqpcpp_1_1_opt_problem"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adc648955f1b21310973857e573c0b4ea"></a>
<a class="el" href="classqcqpcpp_1_1_opt_problem.html#ae5aba17776d02422e2d40bc44f420c3c">SparseEntries</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcqpcpp_1_1_opt_problem.html#adc648955f1b21310973857e573c0b4ea">_linConstrList</a></td></tr>
<tr class="memdesc:adc648955f1b21310973857e573c0b4ea inherit pro_attribs_classqcqpcpp_1_1_opt_problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores values to construct the A linear constraint matrix, unordered. (A, A.cols = n = # of vars, A.rows = m = # of constraints) <br/></td></tr>
<tr class="separator:adc648955f1b21310973857e573c0b4ea inherit pro_attribs_classqcqpcpp_1_1_opt_problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a760036086ae913e599132e2be9dd3cc4 inherit pro_attribs_classqcqpcpp_1_1_opt_problem"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a760036086ae913e599132e2be9dd3cc4"></a>
std::vector&lt; <a class="el" href="classqcqpcpp_1_1_opt_problem.html#ae5aba17776d02422e2d40bc44f420c3c">SparseEntries</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcqpcpp_1_1_opt_problem.html#a760036086ae913e599132e2be9dd3cc4">_quadConstrList</a></td></tr>
<tr class="memdesc:a760036086ae913e599132e2be9dd3cc4 inherit pro_attribs_classqcqpcpp_1_1_opt_problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accumulator for Quadratic constraint values [Q0, Q1, ... Qi ... Qm ]. <br/></td></tr>
<tr class="separator:a760036086ae913e599132e2be9dd3cc4 inherit pro_attribs_classqcqpcpp_1_1_opt_problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f94b8a0a85424ce6e0782ec2ae21b14 inherit pro_attribs_classqcqpcpp_1_1_opt_problem"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7f94b8a0a85424ce6e0782ec2ae21b14"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcqpcpp_1_1_opt_problem.html#a7f94b8a0a85424ce6e0782ec2ae21b14">_updated</a></td></tr>
<tr class="memdesc:a7f94b8a0a85424ce6e0782ec2ae21b14 inherit pro_attribs_classqcqpcpp_1_1_opt_problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">This has to be flipped to true by calling <a class="el" href="classqcqpcpp_1_1_opt_problem.html#a1b0204e2d2b4925d90c17b6f0fa1b046" title="Make sure, to call before optimize is called, but AFTER the problem details are added using the sette...">update()</a> for <a class="el" href="classqcqpcpp_1_1_opt_problem.html#a5f297f555fb0ac17e7512c92efc02a1a" title="Call to run optimization, AFTER the problem details were added, and update() was called. ">optimize()</a> to run. <br/></td></tr>
<tr class="separator:a7f94b8a0a85424ce6e0782ec2ae21b14 inherit pro_attribs_classqcqpcpp_1_1_opt_problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a821de12c61fdcd509910c50e8c5db3fc inherit pro_attribs_classqcqpcpp_1_1_opt_problem"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a821de12c61fdcd509910c50e8c5db3fc"></a>
<a class="el" href="classqcqpcpp_1_1_opt_problem.html#a00fc3821814ec59c74df4a47467b0eb7">VectorX</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcqpcpp_1_1_opt_problem.html#a821de12c61fdcd509910c50e8c5db3fc">_x</a></td></tr>
<tr class="memdesc:a821de12c61fdcd509910c50e8c5db3fc inherit pro_attribs_classqcqpcpp_1_1_opt_problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optimize() stores the solution here when finishing. <br/></td></tr>
<tr class="separator:a821de12c61fdcd509910c50e8c5db3fc inherit pro_attribs_classqcqpcpp_1_1_opt_problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename _Scalar&gt;<br/>
class qcqpcpp::MosekOpt&lt; _Scalar &gt;</h3>

<p>Specialization of optimisation problem to solve using the Mosek solver. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">_Scalar</td><td>Coefficient storage type (floating point). </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a2f044aae8607b879959af0eab5b212e7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Scalar&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classqcqpcpp_1_1_mosek_opt.html">MosekOpt</a>&lt; _Scalar &gt;::<a class="el" href="classqcqpcpp_1_1_mosek_opt.html#a98eacebd160a94e3baa64bad18c56c7e">ReturnType</a> <a class="el" href="classqcqpcpp_1_1_mosek_opt.html">qcqpcpp::MosekOpt</a>&lt; _Scalar &gt;::optimize </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; _Scalar &gt; *&#160;</td>
          <td class="paramname"><em>x_out</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classqcqpcpp_1_1_opt_problem.html#a07145ca39acf400966c4a389cd3d0f11">OBJ_SENSE</a>&#160;</td>
          <td class="paramname"><em>objecitve_sense</em> = <code>OBJ_SENSE::MINIMIZE</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Run optimization using the current solver. <a class="el" href="classqcqpcpp_1_1_mosek_opt.html#a304b5fe236be1a31449e1ca6e78f0bf6" title="Prepare for optimization. Reads parent content and sets up specialized problem. Has to be called befo...">MosekOpt::update()</a> has to be called before. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x_out</td><td>Returns the output, if requested. The output is also stored in <a class="el" href="classqcqpcpp_1_1_opt_problem.html#a821de12c61fdcd509910c50e8c5db3fc" title="Optimize() stores the solution here when finishing. ">OptProblem::_x</a> </td></tr>
    <tr><td class="paramname">objective_sense</td><td>Specifies, whether it's a minimization or a maximization problem. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classqcqpcpp_1_1_opt_problem.html#a5f297f555fb0ac17e7512c92efc02a1a">qcqpcpp::OptProblem&lt; _Scalar &gt;</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/qcqpcpp/<a class="el" href="mosek_opt_problem_8h_source.html">mosekOptProblem.h</a></li>
<li>include/qcqpcpp/impl/<a class="el" href="mosek_opt_problem_8hpp_source.html">mosekOptProblem.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Aug 19 2014 13:44:01 for QCQPcpp by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
